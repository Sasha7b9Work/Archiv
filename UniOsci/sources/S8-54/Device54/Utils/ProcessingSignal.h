#pragma once
#include "Utils/Measures.h"
#include "defines.h"
#include "Data/DataStorage.h"
#include "FPGA/FPGAtypes.h"


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** @addtogroup Utils
 *  @{
 *  @defgroup ProcessingSignal
 *  @{
 */

#define MARKER_VOLTAGE(ch, num)  (markerVoltage[ch][num] - MIN_VALUE)
#define MARKER_TIME(ch, num)    (markerTime[ch][num])

extern int markerVoltage[NumChannels][2];
extern int markerTime[NumChannels][2];

class Processing
{
public:
    /// \brief Установить сигнал для обработки. Данные берутся из DS, inA, inB.
    /// Выходные данные, соответствующие текущим настройками set, рассчитываются сразу и записываются в outA, outB.
    void SetData(bool needSmoothing);
    /// Получить позицию курсора напряжения, соответствующю заданной позиции курсора posCurT
    float GetCursU(Channel ch, float posCurT);
    /// Получить позицию курсора времени, соответствующую заданной позиции курсора напряжения posCurU
    float GetCursT(Channel ch, float posCurU, int numCur);
    /// Аппроксимировать единичное измерение режима рандомизатора функцией sinX/X
    void InterpolationSinX_X(uint8 *data, int numPoints, TBase tBase);
    /// Возвращает строку автоматического измерения
    char* GetStringMeasure(Meas measure, Channel ch, char *buffer, int lenBuf);
    /// Расчитать все измерения
    void CalculateMeasures();
private:
    /// Приведение сигнала к установленным в приборе настройкам
    void CountedToCurrentSettings();
    /// Приведение сигнала к установленному в приборе Range
    void CountedRange(Channel ch);
    /// Приведение сигнала в канале к установленному в приборе TBase
    void CountedTBase();
    /// Приведение количества точек в сигнале к установленным настройкам
    void CountedEnumPoints();
};


extern Processing processing;


/** @}  @}
 */
